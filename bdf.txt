改良点
 BMPファイルの各グリフのあいだにspaceを入れられるようにする

各グリフの
上に 2pixel
左に 2pixel
space(パレット[2])を入れればいい。

グリフとは関係なく、bmpファイルの ライン末に 2pixelぶん spaceを入れる。
bmpファイルの最下行の下 2pixelにspaceを入れる。

何ピクセルあけるか、
-sNN オプションで設定できればいい。
Nは10進数、整数

ついでに、パレット[2]の色も
-c#NNNNNN あるいは -cDDD,DDD,DDD で設定できればいい。
#NNNNNN は16進数、DDD,DDD,DDDは10進数



















7x7サイズのグリフ 229文字を扱うとする
文字仕切りは、縦横同じピクセル数とする。spacing ここでは spacing = 2と決めうちする
BMPファイルに置く横の文字数 colchar ここでは、colchar = 32と決めうちする

BMPファイル 横幅 = (7+2)*32 + 2 = 290
BMPファイル 横幅 bmpw = (gboxw+spacing)*colchar + spacing ということになる。

BMPファイルに置く縦の文字数  rowchar = (229/32) + (229%32!=0) = 8
	//縦の高さは、総文字数を32で割ったものに、あまりが0でないとき
	//さらに1文字ぶん高さを足す
	//例) 34文字あるとき、32文字で 1line、残りの2文字で 1line、計 2line
BMPファイル 縦幅 = (7+2)*8 + 2 = 82
BMPファイル 縦幅 bmph = (gboxh+spacing)*rowchar + spacing ということになる。

bmpファイルの横幅 = 7*32+(2*33) = 290
縦の文字数 rowchar = (229/32) + (229%32!=0) = 8
縦高さ = 7*(8+2)+2 = 82

                                                  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
                         1 1 1 1 1 1 1 1 1 1      7 7 7 7 7 8 8 8 8 8 8 8 8 8 8
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9....  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
0    仕仕仕仕仕仕                                                   仕仕仕仕仕仕
1    仕仕仕仕仕仕                                                   仕仕仕仕仕仕
2    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
3    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
4    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
5    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
6    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
7    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
8    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
9    仕仕仕仕仕仕                                                   仕仕仕仕仕仕
10   仕仕仕仕仕仕                                                   仕仕仕仕仕仕

縦方向の仕切りラインを計算式でもとめる。
仕切り line 0, 1, 9, 10, 18, 19, 27, 28,,...., 73, 81, 82

82:bmph % (7:gboxw+2:spacing) = 0 or 1のとき、
つまり、bmph % (gboxh+spacing) = 0 to spacing-1 の場合は、仕切りだけのラインになる。

次は横を見る。
仕切りは、 0, 1, 9, 10, 18, 19,..., 279, 280, 288, 289

289:bmpw % (7:gboxw+2:spacing) = 0 or 1 同じじゃん
つまり、bmpw % (gboxw+spacing) = 0 to spacing-1 の場合は、仕切りだけのラインになる。

BMP[y][x]
bitmap[g][v][u] とすると、

for(y=0; y<bmph; y=0) //ほんとはBMPファイルなので逆(yが bmph-1から 0になる)にしなくてはならない
	 for(x=0; x<bmpw; x=0)
		if( y%(gboxh+spacing) < spacing )
		  	//横方向全部が 仕切りの行
			bmp[y][x] = palette[2];
		else if( x%(gboxw+spacing) < spacing)
			//仕切りである点
			bmp[y][x] = palette[2];
		else
			bmp[y][x] = bitmap[g][v][u];

こんな感じ。

g,v,uをもとめる
bitmapに格納されている何文字めを読むべきか

  BMPでいま何文字(g)を書いているかは、
   g = (x / (gboxw+spacing)) + (by / (gboxh+spacing))*colchar
       ~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       横、各行ごとに0to32:colchar
                               縦 0から8lineまでは 0, 9to13lineまでは 32..
  で求めることができる。

  bitmapの何文字を読むべきかは、このgを使用すればいい。

bitmapに格納されている文字のどこ(X座標: u, Y座標: v)を読みとるべきか

  bitmap内を読むには、spacingを外した xが必要。それを bx とする。
  x は、BMPファイル 横幅 bmpw = (gboxw+spacing)*colchar + spacing という式で決まっているから、
  bx = x - (spacing*(g%colchar)) - spacing になる。
           ~~~~~~~~~~~~~~~~~~~~~
           いま読んでる文字が横方向に何文字めか * 仕切り

  いっぽう yは、BMPファイル 縦幅 bmph = (gboxh+spacing)*rowchar + spacing で決まっているけど、
  spacingを外した y、すなわち byは、具体的に見ると
  y   by   g
------------
  0   -(無し)
  1   -
  2   0    0
  3   1    0
  4   2    0
  5   3    0
  6   4    0
  7   5    0
  8   6    0
  9   -    -
 10   -    -
 11   7   32
 12   8   32
-----------
 となるから、

  by = y - spacing*(g/colchar) - spacing
           ~~~~~~~~~~~~~~~~~~
           いま読んでる文字が縦方向に何文字めか * 仕切り


   v = by % gboxh
      Yを文字の縦幅で割った余り

   u = bx % gboxw
      Xを文字の横幅で割った余り

こうなる。