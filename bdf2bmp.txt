bdf2bmp   --  convert bdf-font-file to bmp-image-file
version: 0.1
date: Sun Dec 17 19:59:20 2000
author: ITOU Hiroki (itouh@lycos.ne.jp)

●説明
BDFフォントファイルを BMP画像ファイルに変換するソフトウェアです。
8bitカラー(256色)のBMP画像ファイルを生成します。

使いかたは、
$  bdf2bmp input.bdf output.bmp
でOK。

●ファイル
bdf2bmp01.c    ソースコード
bdf2bmp01.txt  ドキュメント(このファイル)
bdf2bmp01.exe  Windowsで動作するバイナリ

●コンパイル
Borland C++ Compiler 5.5.1 for Win32 + Windows98SecondEditon日本語版
を使用してコンパイルしました。
Copyright (c) 1993, 2000 Borland

gcc 2.7.2.3 + FreeBSD 3.5.1Rでもコンパイル、動作することを確認しました。
そのときは bdf2bmp01.c の文字コードを、元はShift_JISですが、EUC-JAPANに
変換してからコンパイルしてください。

●現在の制限
各グリフごとにオフセットを変えてある BDFファイル(たとえば courR18.bdf)
には対応してません。位置がずれた画像を生成してしまいます。
(理由: このソフトウェアがオフセットをまったく見てないから。)

現在対応している BDFファイルは
k14-goth, sinonome12, sinonome16, 7x14, 7x14rk, 8x16rk など、
オフセットがない(というかどのグリフもオフセットが同じ)ファイルだけです。

--
ITOU Hiroki
http://www.geocities.co.jp/Playtown-Domino/7021/



----------------------------------------------------------------------
以下は作成途中のドキュメント。読む必要なし。


BDFから bitmapへ:
  1文字ずつ、出てきた順にメモリに書きこむ

読みとるときは、
  c文字めのデータが欲しい、とする。
  cのアドレス(始点)は、(文字の縦の高さ*文字の横幅)*c で得られる。
	例) 0文字めのデータは、c=0だから addr 0から、
	1文字めのデータは c=1だから (文字の縦の高さ*文字の横幅)、
	2文字めのデータは(文字の縦の高さ*文字の横幅)*2、...

  cのbitmapデータを c[y][x]に代入するなら、
  for(y=0; y<縦の高さ; y++)
	  for(x=0; x<横幅; x++)
		  glyph[y][x] = *( (文字の縦の高さ*文字の横幅) + y*横幅 + x);
  でよい。
	例)
	メモリ上に
	0001000
	0010100
	0100010
	0111110
	0100010
	0100010
	0000000

	と置かれているbitmapの場合、
	(ほんとは横につながってる。000100000101000111110010001001000100000000 )
	(離して書けば、0001000 0010100 0111110 0100010 0100010 0000000 )

	 x 0123456
	y
	0  0001000
	1  0010100
	2  0100010
	3  0111110
	4  0100010
	5  0100010
	6  0000000

	となる。
	

bitmapから BMPへ:
	bitmapになっている各文字を、1枚のBMP画像にする

	bitmapはメモリ上にこういうふうに置いてある、とする。

	0000000 0文字め
	0111100
	0000010
	0011110
	0100010
	0111110
	0000000

	0100000 1文字め
	0100000
	0111100
	0100010
	0100010
	0111100
	0000000

	...

	0001000 31文字め
	0010100
	0100010
	0111110
	0100010
	0100010
	0000000

	0111100 32文字め
	0100010
	0111100
	0100010
	0100010
	0111100
	0000000
	
	このとき、BMPファイルでは次のようにしたい。(32文字で折り返す)
	(v..BMPの Y座標、u...BMPの X座標)

	 u0123456 7...               .ここがsの右端
	v
	0 0000000 0100000 .... 0001000 
	1 0111100 0100000      0010100
	2 0000010 0111100      0100010
	3 0011110 0100010      0111110
	4 0100010 0100010      0100010
	5 0111110 0111100      0100010
	6 0000000 0000000      0000000

	7 0111100
	. 0100010
	. 0111100	  
	  0100010
	  0100010
	  0111100	  
	  0000000
	  .
	  .
アドレス
        7x7x0+7x0                  ;7x7x1                      ;7x7x2+7x0
	000 001 002 003 004 005 006 049 050 051 052 053 054 055 098 099

                           ;7x7x3
	100 101 102 103 104 187 188 189.....
                                                       2lineめ始まり
	   ;7x7x31                    1 lineめ;まで   ;7x7x0+(7x1)
        ... 1519 1520 1521 1522 1523 1524 1525 padding 007 008 009 010 011 012

           ;7x7x1+7                    ;    ;7x7x31+7
	013 056 057 058 059 060 061 062 .... 1526 1527 1528 1529 1530
 
            2line;まで   ;3line7x7x0+(7x2)  ;6line(7x7x0+7x6   7x7x1+7x6;
	1531 1532 padding 014 015 .......... 042 043 044 045 046 047 048 091..

           ;7x7x31+7x6                   6line;まで   ;7line7x7x32+0
	... 1561 1562 1563 1564 1565 1566 1567 padding 1568 1569 1570 1571

                      ;7x7x33+0                          ;7x7x34+0
	1572 1573 1574 1617 1618 1619 1620 1621 1622 1623 1666 1667...


このとき、
 0 lineめは、7(height) * 7(width) * 0to31(glyph) + 7(width) * 0(line)
 1 lineめは、7 * 7 * 0to31 + 7 * 1(line)
 6 lineめは、7 * 7 * 0to31 + 7 * 7(line)
 7 lineめは、7 * 7 * 32to63(glyph) + 7 * 0(line)


(x,y) = BMPの座標(左上が0,0);  (u,v) = (各文字内の座標)
g 今読みこんでいる文字が何文字めか

for(y=0; y<BMPの縦の高さ(bmpH); y++){
	for(x=0; x<bmpW; x++){
		g = x/文字の横幅(fbbxW) + (y/文字の縦高さ(fbbxH))*32;
		//  ~~~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~
		//  はんい 0 to 31        はんい 0to6lineでは0,7to13lineでは32

		u_char = *((fbbxH*fbbxW*g) + (fbbxW*(y%fbbxH)) + (x%fbbxW));
		

 (fbbxH*fbbxW)*g + fbbxW*y
