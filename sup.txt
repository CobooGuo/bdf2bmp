----------------------------------------------------------------------
作成途中のドキュメント。読む必要なし。
------------------------------------------------------------ver0.4

------------------------------------------------------------ver0.3
改良点
 BMPファイルの各グリフのあいだにspaceを入れられるようにする

各グリフの
上に 2pixel
左に 2pixel
space(パレット[2])を入れればいい。

グリフとは関係なく、bmpファイルの ライン末に 2pixelぶん spaceを入れる。
bmpファイルの最下行の下 2pixelにspaceを入れる。

何ピクセルあけるか、
-sNN オプションで設定できればいい。
Nは10進数、整数

ついでに、パレット[2]の色も
-c#NNNNNN あるいは -cDDD,DDD,DDD で設定できればいい。
#NNNNNN は16進数、DDD,DDD,DDDは10進数



















7x7サイズのグリフ 229文字を扱うとする
文字仕切りは、縦横同じピクセル数とする。spacing ここでは spacing = 2と決めうちする
BMPファイルに置く横の文字数 colchar ここでは、colchar = 32と決めうちする

BMPファイル 横幅 = (7+2)*32 + 2 = 290
BMPファイル 横幅 bmpw = (gboxw+spacing)*colchar + spacing ということになる。

BMPファイルに置く縦の文字数  rowchar = (229/32) + (229%32!=0) = 8
	//縦の高さは、総文字数を32で割ったものに、あまりが0でないとき
	//さらに1文字ぶん高さを足す
	//例) 34文字あるとき、32文字で 1line、残りの2文字で 1line、計 2line
BMPファイル 縦幅 = (7+2)*8 + 2 = 82
BMPファイル 縦幅 bmph = (gboxh+spacing)*rowchar + spacing ということになる。

bmpファイルの横幅 = 7*32+(2*33) = 290
縦の文字数 rowchar = (229/32) + (229%32!=0) = 8
縦高さ = 7*(8+2)+2 = 82

                                                  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
                         1 1 1 1 1 1 1 1 1 1      7 7 7 7 7 8 8 8 8 8 8 8 8 8 8
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9....  5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
0    仕仕仕仕仕仕                                                   仕仕仕仕仕仕
1    仕仕仕仕仕仕                                                   仕仕仕仕仕仕
2    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
3    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
4    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
5    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
6    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
7    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
8    仕仕□■□■□□□仕仕□■□■□□□仕仕   □■□□□仕仕□■□■□□□仕仕
9    仕仕仕仕仕仕                                                   仕仕仕仕仕仕
10   仕仕仕仕仕仕                                                   仕仕仕仕仕仕

縦方向の仕切りラインを計算式でもとめる。
仕切り line 0, 1, 9, 10, 18, 19, 27, 28,,...., 73, 81, 82

82:bmph % (7:gboxw+2:spacing) = 0 or 1のとき、
つまり、bmph % (gboxh+spacing) = 0 to spacing-1 の場合は、仕切りだけのラインになる。

次は横を見る。
仕切りは、 0, 1, 9, 10, 18, 19,..., 279, 280, 288, 289

289:bmpw % (7:gboxw+2:spacing) = 0 or 1 同じじゃん
つまり、bmpw % (gboxw+spacing) = 0 to spacing-1 の場合は、仕切りだけのラインになる。

BMP[y][x]
bitmap[g][v][u] とすると、

for(y=0; y<bmph; y=0) //ほんとはBMPファイルなので逆(yが bmph-1から 0になる)にしなくてはならない
	 for(x=0; x<bmpw; x=0)
		if( y%(gboxh+spacing) < spacing )
		  	//横方向全部が 仕切りの行
			bmp[y][x] = palette[2];
		else if( x%(gboxw+spacing) < spacing)
			//仕切りである点
			bmp[y][x] = palette[2];
		else
			bmp[y][x] = bitmap[g][v][u];

こんな感じ。

g,v,uをもとめる
bitmapに格納されている何文字めを読むべきか

  BMPでいま何文字(g)を書いているかは、
   g = (x / (gboxw+spacing)) + (by / (gboxh+spacing))*colchar
       ~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       横、各行ごとに0to32:colchar
                               縦 0から8lineまでは 0, 9to13lineまでは 32..
  で求めることができる。

  bitmapの何文字を読むべきかは、このgを使用すればいい。

bitmapに格納されている文字のどこ(X座標: u, Y座標: v)を読みとるべきか

  bitmap内を読むには、spacingを外した xが必要。それを bx とする。
  x は、BMPファイル 横幅 bmpw = (gboxw+spacing)*colchar + spacing という式で決まっているから、
  bx = x - (spacing*(g%colchar)) - spacing になる。
           ~~~~~~~~~~~~~~~~~~~~~
           いま読んでる文字が横方向に何文字めか * 仕切り

  いっぽう yは、BMPファイル 縦幅 bmph = (gboxh+spacing)*rowchar + spacing で決まっているけど、
  spacingを外した y、すなわち byは、具体的に見ると
  y   by   g
------------
  0   -(無し)
  1   -
  2   0    0
  3   1    0
  4   2    0
  5   3    0
  6   4    0
  7   5    0
  8   6    0
  9   -    -
 10   -    -
 11   7   32
 12   8   32
-----------
 となるから、

  by = y - spacing*(g/colchar) - spacing
           ~~~~~~~~~~~~~~~~~~
           いま読んでる文字が縦方向に何文字めか * 仕切り


   v = by % gboxh
      Yを文字の縦幅で割った余り

   u = bx % gboxw
      Xを文字の横幅で割った余り

こうなる。


------------------------------------------------------------ver0.2
改良点
オフセットを読み、courR18.bdfもきちんと読めるようにする。

FONTBOUNDINGBOX 12 19 -1 -4
BBX 8 12 2 0
0F	□□□□■■■■
10	□□□■□□□□
20	□□■□□□□□
20	□□■□□□□□
FE	■■■■■■■□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
FE	■■■■■■■□

これ(■=1, □=0) を、以下のようにしたい。
        ┌ 3┐
0000	□□□□□□□□□□□□
0000	□□□□□□□□□□□□
0000	□□□□□□□□□□□□
03c0	□□□□□□□■■■■□
0100	□□□□□□■□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
3f80	□□□■■■■■■■□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
3f80	□□□■■■■■■■□□
0000  ┌□□□□□□□□□□□□
0000  4 □□□□□□□□□□□□
0000	□□□□□□□□□□□□
0000  └□□□□□□□□□□□□

3 = -(-1) + 2
4 = -(-4) + 0

FONTBOUNDINGBOX 12 19 -1 -4
STARTCHAR quotedbl
ENCODING 34
SWIDTH 600 0
DWIDTH 11 0
BBX 5 5 3 7
BITMAP
D8	##-##---
D8	##-##---
D8	##-##---
90	#--#----
90	#--#----

これは、
  ┌  4 ┐
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□■■□■■□□□
  □□□□■■□■■□□□
  □□□□■■□■■□□□
  □□□□■□□■□□□□
  □□□□■□□■□□□□
┌□□□□□□□□□□□□
│□□□□□□□□□□□□
  □□□□□□□□□□□□
11□□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
│□□□□□□□□□□□□
└□□□□□□□□□□□□

となるべきはず。
4 = -(-1) + 3
11 = -(-4) + 7

FONTBOUNDINGBOX gboxw gboxh goffx goffy
BBX nowboxw nowboxh nowoffx nowoffy
とすると、
グリフ左の空白 leftoff =  -goffx + nowoffx
グリフ下の空白 bottomoff = -goffy + nowoffy
である。
では、
グリフ上の空白は、 topoff = gboxh - nowboxh - (-goffy + nowoffy)
である。
グリフ右の空白は、 rightoff = gboxw - nowboxw - (-goffx + nowoffx)
だけどこれはいらない。 



まず、
1) BDFフォントファイルの、BBX ...を読み、「個々のグリフ」オフセットを読みとる。
   FONTBOUNDINGBOX の「グローバル」オフセットも読んでおかなければ。
2) その2つの数値を元に、「個々のグリフ」オフセットをずらして、「グローバル」オフセットに一致するようにする。


オフセットは、ビットマップ画像の左下隅を基準にずれる。だから、左下隅までのデータ(すなわちグリフ1個まるごと)を一度に得なければならない。
ver0.1では1行ごとに処理してたけど、ver0.2では個々のグリフについて、全部のビットマップデータをbufferにためて、
ENDCHARになったら、一度にもらう、という形式にしよう。

ずらしかたは、
まず、もらった16進数の文字列からbitmap(呼称 bitA)を作る。それとは別に、グローバルboxW*グローバルboxHの大きさがある領域(呼称 bitB)も作る。
bitA をオフセットを考慮しながら、bitBにコピーする。bitBをbitmap用領域に書き込む。
そのとき、bitBの原点が FONTBOUNDINGBOX「フォント全体」のオフセット値(goffx,goffy)になるわけである。そして、それに「個々のグリフ」のオフセット(nowoffx, nowoffy)を足すわけだから、
bitAの左下隅のbitBにおける座標は、X: -goffx + nowoffx,  Y: -goffy + nowoffy となる。ほかのビットもこれに準じてずれる。


bitAの領域サイズは、
	横幅=(16進数の1行の長さ-改行コード1)x4
	縦高さ=改行の数=(16進数のために使用した領域の大きさ / (16進数の1行の大きさ(改行含む))

16進数文字列を bitmapに変換:
	1文字読みこむ、4文字の2進数文字列に変換、1文字ずつbitmapに代入していく

bitAをbitBに移すとき、
	bitAの下から読んでいく(bitAの左下隅から右上へと読む)
	bitAの左下隅は、(-goffx+nowoffx, -goffy+nowoffy)である。

bitB(i,j)に書くとき、
	i < -goffy+nowoffy ならば(文字の下側の空き)、書かない
	i > -goffy+nowoffy + bitAの縦サイズ ならば(文字の上側の空き)、書かない

	j < -goffx+nowoffx ならば(文字の左側の空きの部分は)、書かない(あるいは 0(=空白)を書く)
	j > -goffx+nowoffx + hexlen*4 ならば(文字の右側の空き)、書かない

	それ以外ならば、書き込む
	*(bitB領域の最初 + i*bitBの横幅 + j)に書きこむ
	*(bitA領域の最初 + bitAの横幅*(i-(-goffy+nowoffy)) + 

i*(i - (-goffy+nowoffy))*hexlen*4) + (j - (-goffx+nowoffx)                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~                             bitAの横幅




freeすると メモリ違反するのでいろいろ調べてたけど、全然関係ないところで、unsigned char* p; ...... free(p); とだけ、してるのが原因だった。freeするポインタは、宣言のときに = NULLしておけばいいかな。














------------------------------------------------------------v0.1.1

BDFから bitmapへ:
  1文字ずつ、出てきた順にメモリに書きこむ

読みとるときは、
  c文字めのデータが欲しい、とする。
  cのアドレス(始点)は、(文字の縦の高さ*文字の横幅)*c で得られる。
	例) 0文字めのデータは、c=0だから addr 0から、
	1文字めのデータは c=1だから (文字の縦の高さ*文字の横幅)、
	2文字めのデータは(文字の縦の高さ*文字の横幅)*2、...

  cのbitmapデータを c[y][x]に代入するなら、
  for(y=0; y<縦の高さ; y++)
	  for(x=0; x<横幅; x++)
		  glyph[y][x] = *( (文字の縦の高さ*文字の横幅) + y*横幅 + x);
  でよい。
	例)
	メモリ上に
	0001000
	0010100
	0100010
	0111110
	0100010
	0100010
	0000000

	と置かれているbitmapの場合、
	(ほんとは横につながってる。000100000101000111110010001001000100000000 )
	(離して書けば、0001000 0010100 0111110 0100010 0100010 0000000 )

	 x 0123456
	y
	0  0001000
	1  0010100
	2  0100010
	3  0111110
	4  0100010
	5  0100010
	6  0000000

	となる。
	

bitmapから BMPへ:
	bitmapになっている各文字を、1枚のBMP画像にする

	bitmapはメモリ上にこういうふうに置いてある、とする。

	0000000 0文字め
	0111100
	0000010
	0011110
	0100010
	0111110
	0000000

	0100000 1文字め
	0100000
	0111100
	0100010
	0100010
	0111100
	0000000

	...

	0001000 31文字め
	0010100
	0100010
	0111110
	0100010
	0100010
	0000000

	0111100 32文字め
	0100010
	0111100
	0100010
	0100010
	0111100
	0000000
	
	このとき、BMPファイルでは次のようにしたい。(32文字で折り返す)
	(v..BMPの Y座標、u...BMPの X座標)

	 u0123456 7...               .ここがsの右端
	v
	0 0000000 0100000 .... 0001000 
	1 0111100 0100000      0010100
	2 0000010 0111100      0100010
	3 0011110 0100010      0111110
	4 0100010 0100010      0100010
	5 0111110 0111100      0100010
	6 0000000 0000000      0000000

	7 0111100
	. 0100010
	. 0111100	  
	  0100010
	  0100010
	  0111100	  
	  0000000
	  .
	  .
アドレス
        7x7x0+7x0                  ;7x7x1                      ;7x7x2+7x0
	000 001 002 003 004 005 006 049 050 051 052 053 054 055 098 099

                           ;7x7x3
	100 101 102 103 104 187 188 189.....
                                                       2lineめ始まり
	   ;7x7x31                    1 lineめ;まで   ;7x7x0+(7x1)
        ... 1519 1520 1521 1522 1523 1524 1525 padding 007 008 009 010 011 012

           ;7x7x1+7                    ;    ;7x7x31+7
	013 056 057 058 059 060 061 062 .... 1526 1527 1528 1529 1530
 
            2line;まで   ;3line7x7x0+(7x2)  ;6line(7x7x0+7x6   7x7x1+7x6;
	1531 1532 padding 014 015 .......... 042 043 044 045 046 047 048 091..

           ;7x7x31+7x6                   6line;まで   ;7line7x7x32+0
	... 1561 1562 1563 1564 1565 1566 1567 padding 1568 1569 1570 1571

                      ;7x7x33+0                          ;7x7x34+0
	1572 1573 1574 1617 1618 1619 1620 1621 1622 1623 1666 1667...


このとき、
 0 lineめは、7(height) * 7(width) * 0to31(glyph) + 7(width) * 0(line)
 1 lineめは、7 * 7 * 0to31 + 7 * 1(line)
 6 lineめは、7 * 7 * 0to31 + 7 * 7(line)
 7 lineめは、7 * 7 * 32to63(glyph) + 7 * 0(line)


(x,y) = BMPの座標(左上が0,0);  (u,v) = (各文字内の座標)
g 今読みこんでいる文字が何文字めか

for(y=0; y<BMPの縦の高さ(bmpH); y++){
	for(x=0; x<bmpW; x++){
		g = x/文字の横幅(fbbxW) + (y/文字の縦高さ(fbbxH))*32;
		//  ~~~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~
		//  はんい 0 to 31        はんい 0to6lineでは0,7to13lineでは32

		u_char = *((fbbxH*fbbxW*g) + (fbbxW*(y%fbbxH)) + (x%fbbxW));


