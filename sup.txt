
----------------------------------------------------------------------
以下は作成途中のドキュメント。読む必要なし。

------------------------------------------------------------ver0.2
改良点
オフセットを読み、courR18.bdfもきちんと読めるようにする。

FONTBOUNDINGBOX 12 19 -1 -4
BBX 8 12 2 0
0F	□□□□■■■■
10	□□□■□□□□
20	□□■□□□□□
20	□□■□□□□□
FE	■■■■■■■□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
20	□□■□□□□□
FE	■■■■■■■□

これ(■=1, □=0) を、以下のようにしたい。
        ┌ 3┐
0000	□□□□□□□□□□□□
0000	□□□□□□□□□□□□
0000	□□□□□□□□□□□□
03c0	□□□□□□□■■■■□
0100	□□□□□□■□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
3f80	□□□■■■■■■■□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
0800	□□□□□■□□□□□□
3f80	□□□■■■■■■■□□
0000  ┌□□□□□□□□□□□□
0000  4 □□□□□□□□□□□□
0000	□□□□□□□□□□□□
0000  └□□□□□□□□□□□□

3 = -(-1) + 2
4 = -(-4) + 0

FONTBOUNDINGBOX 12 19 -1 -4
STARTCHAR quotedbl
ENCODING 34
SWIDTH 600 0
DWIDTH 11 0
BBX 5 5 3 7
BITMAP
D8	##-##---
D8	##-##---
D8	##-##---
90	#--#----
90	#--#----

これは、
  ┌  4 ┐
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□■■□■■□□□
  □□□□■■□■■□□□
  □□□□■■□■■□□□
  □□□□■□□■□□□□
  □□□□■□□■□□□□
┌□□□□□□□□□□□□
│□□□□□□□□□□□□
  □□□□□□□□□□□□
11□□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
  □□□□□□□□□□□□
│□□□□□□□□□□□□
└□□□□□□□□□□□□

となるべきはず。
4 = -(-1) + 3
11 = -(-4) + 7

FONTBOUNDINGBOX gboxw gboxh goffx goffy
BBX nowboxw nowboxh nowoffx nowoffy
とすると、
グリフ左の空白 leftoff =  -goffx + nowoffx
グリフ下の空白 bottomoff = -goffy + nowoffy
である。
では、
グリフ上の空白は、 topoff = gboxh - nowboxh - (-goffy + nowoffy)
である。
グリフ右の空白は、 rightoff = gboxw - nowboxw - (-goffx + nowoffx)
だけどこれはいらない。 



まず、
1) BDFフォントファイルの、BBX ...を読み、「個々のグリフ」オフセットを読みとる。
   FONTBOUNDINGBOX の「グローバル」オフセットも読んでおかなければ。
2) その2つの数値を元に、「個々のグリフ」オフセットをずらして、「グローバル」オフセットに一致するようにする。


オフセットは、ビットマップ画像の左下隅を基準にずれる。だから、左下隅までのデータ(すなわちグリフ1個まるごと)を一度に得なければならない。
ver0.1では1行ごとに処理してたけど、ver0.2では個々のグリフについて、全部のビットマップデータをbufferにためて、
ENDCHARになったら、一度にもらう、という形式にしよう。

ずらしかたは、
まず、もらった16進数の文字列からbitmap(呼称 bitA)を作る。それとは別に、グローバルboxW*グローバルboxHの大きさがある領域(呼称 bitB)も作る。
bitA をオフセットを考慮しながら、bitBにコピーする。bitBをbitmap用領域に書き込む。
そのとき、bitBの原点が FONTBOUNDINGBOX「フォント全体」のオフセット値(goffx,goffy)になるわけである。そして、それに「個々のグリフ」のオフセット(nowoffx, nowoffy)を足すわけだから、
bitAの左下隅のbitBにおける座標は、X: -goffx + nowoffx,  Y: -goffy + nowoffy となる。ほかのビットもこれに準じてずれる。


bitAの領域サイズは、
	横幅=(16進数の1行の長さ-改行コード1)x4
	縦高さ=改行の数=(16進数のために使用した領域の大きさ / (16進数の1行の大きさ(改行含む))

16進数文字列を bitmapに変換:
	1文字読みこむ、4文字の2進数文字列に変換、1文字ずつbitmapに代入していく

bitAをbitBに移すとき、
	bitAの下から読んでいく(bitAの左下隅から右上へと読む)
	bitAの左下隅は、(-goffx+nowoffx, -goffy+nowoffy)である。

bitB(i,j)に書くとき、
	i < -goffy+nowoffy ならば(文字の下側の空き)、書かない
	i > -goffy+nowoffy + bitAの縦サイズ ならば(文字の上側の空き)、書かない

	j < -goffx+nowoffx ならば(文字の左側の空きの部分は)、書かない(あるいは 0(=空白)を書く)
	j > -goffx+nowoffx + hexlen*4 ならば(文字の右側の空き)、書かない

	それ以外ならば、書き込む
	*(bitB領域の最初 + i*bitBの横幅 + j)に書きこむ
	*(bitA領域の最初 + bitAの横幅*(i-(-goffy+nowoffy)) + 

i*(i - (-goffy+nowoffy))*hexlen*4) + (j - (-goffx+nowoffx)                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~                             bitAの横幅




freeすると メモリ違反するのでいろいろ調べてたけど、全然関係ないところで、unsigned char* p; ...... free(p); とだけ、してるのが原因だった。freeするポインタは、宣言のときに = NULLしておけばいいかな。














------------------------------------------------------------v0.1.1

BDFから bitmapへ:
  1文字ずつ、出てきた順にメモリに書きこむ

読みとるときは、
  c文字めのデータが欲しい、とする。
  cのアドレス(始点)は、(文字の縦の高さ*文字の横幅)*c で得られる。
	例) 0文字めのデータは、c=0だから addr 0から、
	1文字めのデータは c=1だから (文字の縦の高さ*文字の横幅)、
	2文字めのデータは(文字の縦の高さ*文字の横幅)*2、...

  cのbitmapデータを c[y][x]に代入するなら、
  for(y=0; y<縦の高さ; y++)
	  for(x=0; x<横幅; x++)
		  glyph[y][x] = *( (文字の縦の高さ*文字の横幅) + y*横幅 + x);
  でよい。
	例)
	メモリ上に
	0001000
	0010100
	0100010
	0111110
	0100010
	0100010
	0000000

	と置かれているbitmapの場合、
	(ほんとは横につながってる。000100000101000111110010001001000100000000 )
	(離して書けば、0001000 0010100 0111110 0100010 0100010 0000000 )

	 x 0123456
	y
	0  0001000
	1  0010100
	2  0100010
	3  0111110
	4  0100010
	5  0100010
	6  0000000

	となる。
	

bitmapから BMPへ:
	bitmapになっている各文字を、1枚のBMP画像にする

	bitmapはメモリ上にこういうふうに置いてある、とする。

	0000000 0文字め
	0111100
	0000010
	0011110
	0100010
	0111110
	0000000

	0100000 1文字め
	0100000
	0111100
	0100010
	0100010
	0111100
	0000000

	...

	0001000 31文字め
	0010100
	0100010
	0111110
	0100010
	0100010
	0000000

	0111100 32文字め
	0100010
	0111100
	0100010
	0100010
	0111100
	0000000
	
	このとき、BMPファイルでは次のようにしたい。(32文字で折り返す)
	(v..BMPの Y座標、u...BMPの X座標)

	 u0123456 7...               .ここがsの右端
	v
	0 0000000 0100000 .... 0001000 
	1 0111100 0100000      0010100
	2 0000010 0111100      0100010
	3 0011110 0100010      0111110
	4 0100010 0100010      0100010
	5 0111110 0111100      0100010
	6 0000000 0000000      0000000

	7 0111100
	. 0100010
	. 0111100	  
	  0100010
	  0100010
	  0111100	  
	  0000000
	  .
	  .
アドレス
        7x7x0+7x0                  ;7x7x1                      ;7x7x2+7x0
	000 001 002 003 004 005 006 049 050 051 052 053 054 055 098 099

                           ;7x7x3
	100 101 102 103 104 187 188 189.....
                                                       2lineめ始まり
	   ;7x7x31                    1 lineめ;まで   ;7x7x0+(7x1)
        ... 1519 1520 1521 1522 1523 1524 1525 padding 007 008 009 010 011 012

           ;7x7x1+7                    ;    ;7x7x31+7
	013 056 057 058 059 060 061 062 .... 1526 1527 1528 1529 1530
 
            2line;まで   ;3line7x7x0+(7x2)  ;6line(7x7x0+7x6   7x7x1+7x6;
	1531 1532 padding 014 015 .......... 042 043 044 045 046 047 048 091..

           ;7x7x31+7x6                   6line;まで   ;7line7x7x32+0
	... 1561 1562 1563 1564 1565 1566 1567 padding 1568 1569 1570 1571

                      ;7x7x33+0                          ;7x7x34+0
	1572 1573 1574 1617 1618 1619 1620 1621 1622 1623 1666 1667...


このとき、
 0 lineめは、7(height) * 7(width) * 0to31(glyph) + 7(width) * 0(line)
 1 lineめは、7 * 7 * 0to31 + 7 * 1(line)
 6 lineめは、7 * 7 * 0to31 + 7 * 7(line)
 7 lineめは、7 * 7 * 32to63(glyph) + 7 * 0(line)


(x,y) = BMPの座標(左上が0,0);  (u,v) = (各文字内の座標)
g 今読みこんでいる文字が何文字めか

for(y=0; y<BMPの縦の高さ(bmpH); y++){
	for(x=0; x<bmpW; x++){
		g = x/文字の横幅(fbbxW) + (y/文字の縦高さ(fbbxH))*32;
		//  ~~~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~
		//  はんい 0 to 31        はんい 0to6lineでは0,7to13lineでは32

		u_char = *((fbbxH*fbbxW*g) + (fbbxW*(y%fbbxH)) + (x%fbbxW));


